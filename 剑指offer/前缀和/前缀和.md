### 前缀和
#### 一、什么是前缀和？
> 对于一个给定的数列 _**A**_ ，它的前缀和数列 _**S**_ 中 _**S**_[i] 表示从第 1 个元素到第 i 个元素的总和。用公式表示为：
```
$S = [0];
for ($i=0; $i<count($A); $i++) { 
    $S[$i+1] = $S[$i] + $A[$i];
}
```
例如：数列 _**A**_ 为[1,2,3,4,5,6]
S[0] = 0;
S[1] = 1;
S[2] = 1 + 2 = 3；
...
S[6] = 1 + 2 + 3 + 4 + 5 + 6 = 21;
那么前缀和数列 _**S**_ 为[0,1,3,6,10,15,21]


**注**：为保证一致性，数组的前 1 项和、前 2 项和...将 S 数组下标为 0 的值赋值为 0；

#### 二、前缀和的应用
###### 和为K的子数组
> 给定一个整数数组和一个整数 k，可以**找到该数组中和为 k 的连续的子数组的个数。**
#### 三、前缀和的示例
###### （一）问题描述
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
```
输入：$nums = [1,6,2,2,4,2]; $k = 8;
输出：3。[6,2] [2,2,4] [2,4,2]
```
###### （二）问题分析
要求 `连续子数组和为 k 的个数`，即求 nums[i,...,j] 的和为 k 的个数，其中 0<=i<=j<=count(nums)-1 。

数列：a1,a2,a3,...,an+1,...
S3 = a1+a2+a3;
S7 = a1+a2+a3+...+a7;
假如我要求连续子数列 a4,a5,a6,a7 的和怎么办？
S7-S3 = a4+a5+...+a7;

同理那么如果我们想求 nums[i..j] 的和，只需要一步操作 S[j+1]- S[i] 即可，而不需要重新去遍历数组了。（注：nums 数组的下标是从零开始的。）

回到这个子数组问题，我们想求有多少个子数组的和为 k，借助前缀和技巧很容易写出一个解法：
###### （三）参考代码
```
class PrefixSum{
	public $nums;
	public $k;
	public function __construct(array $nums, $k){
		$this->nums = $nums;
		$this->k    = $k;
	}
	public function subArraySum(){
		$sum = [0];
        
		for ($i=0; $i<count($this->nums); $i++) { 
			$sum[$i+1] = $sum[$i] + $this->nums[$i];
		}
		$ans = 0;
        // 枚举
		for($i=1;$i<count($sum);$i++){
			for($j=0;$j<$i;$j++){
				if($sum[$i] - $sum[$j] == $this->k){
					$ans++;
				}
			}
		}
		return $ans;
	}
}
$obj = new PrefixSum([1,6,2,2,4,2],8);
$re = $obj->subArraySum();
var_dump($re);// 3
```
###### （四）优化代码
（1）遍历 nums 数组的循环肯定少不了。
（2）所以能优化的地方在内层循环。
（3）先看一下优化后的参考代码：
```
class PrefixSum{
	public $nums;
	public $k;
	public function __construct(array $nums,$k){
		$this->nums = $nums;
		$this->k    = $k; 
	}
	public function subArraySum(){
		$preSum = [0=>1];
		$ans    = 0;
		$sum0_i = 0;
		for($i=0;$i<count($this->nums);$i++){
			$sum0_i += $this->nums[$i];
			$sum0_j  = $sum0_i - $this->k;
			if(array_key_exists($sum0_j,$preSum)){
				$ans += $preSum[$sum0_j];
			}  
			if(array_key_exists($sum0_i,$preSum)){
				$preSum[$sum0_i] = $preSum[$sum0_i] + 1;
			}else{
				$preSum[$sum0_i] = 1;
			}
		}	
		return $ans;
	}		
}
$obj = new PrefixSum([1,6,2,2,4,2],8);
$re = $obj->subArraySum();
var_dump($re);// 3
```
（4）优化分析：
#### 四、类似问题
1. 向下的路径节点值之和。

#### 参考资料
[前缀和](https://zhuanlan.zhihu.com/p/436526162)
[前缀和技巧](https://zhuanlan.zhihu.com/p/107778275)
[什么是前缀和?](https://juejin.cn/post/6944913393627168798)