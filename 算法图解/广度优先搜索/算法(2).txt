1. 广度优先搜索
思路：
1.1 找出1环内的所有朋友，形成一个队列。
1.2 挨个检查队列中的每个朋友，判断其是否被查找过。（对于检查过的人，务必不要再检查。原因：避免做无用功，防止无限循环）
	1.2.1 如果是，则不处理。
	1.2.2 如果不是，则判断其是否是芒果销售商。
		1.2.2.1 如果是，则将其保存在数组中。
		1.2.2.2 如果不是，则将该该朋友的朋友添加到队列中，并且将其标记为已检查。
2. 迪杰特斯拉算法
？1：怎么找出路径。
迪杰特斯拉算法的返回值：
1. 从起点到终点最短路径的值。
2. 一个关联数组，键为子节点，值为父节点。
如：
$parents = [
	'b'   => 'start',
	'a'   => 'b',
	'fin' => 'a'
];

记住父节点，循环遍历，找到该节点并将该节点的子节点更新为父节点。
记住-->循环-->找到-->更新
具体步骤：

1. 用一个父节点的变量去存储根节点
2. 循环遍历数组，找出该节点。
3. 将该节点的子节点更新为父节点变量。

-------------------------------------
代码：
<?php
$parents = [
	'b'   => 'start',
	'a'   => 'b',
	'fin' => 'a'
];
function route($parents){
	// 1. 首先用fatherNode变量记住根节点
	$fatherNode = 'start';
	$route = [$fatherNode];
	$processed = [];
	for($i=0;$i<count($parents);$i++){
		foreach($parents as $k => $v){
			if(in_array($k,$processed)){
				continue;
			}
  			// 找出该节点
			if($v === $fatherNode){
				// 将该节点的子节点更新为父节点变量。
				$fatherNode = $k;
				$route[] = $k;
				$processed[] = $k;
			}
		}
	}
	return $route;
}
$re = route($parents);
var_dump($re);
?>